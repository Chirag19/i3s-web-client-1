$(function() {
    const VERTEX_ELEMENTS_PER_TRIANGLE = 9;
    const NORMAL_ELEMENTS_PER_TRIANGLE = 9;
    Cesium.BingMapsApi.defaultKey = "AmdoJEIiP8BcA__QO9SjBAgv4h73-uiH4lGinmzwyfjK-Fjs8t7GbmfpFjmyj1cl";
    var osm = Cesium.createOpenStreetMapImageryProvider({
        url: "https://a.tile.openstreetmap.org/"
    });
    var viewer = new Cesium.Viewer("cesiumContainer",{
        baseLayerPicker: false,
        imageryProvider: osm,
        fullscreenButton: false,
        scene3DOnly: true,
        timeline: false,
        animation: false,
        selectionIndicator: true,
        infoBox: true
    });
    var entities = viewer.entities;
    var scene = viewer.scene;
    var statusBar = new StatusBar; // from helper

    var defaultStyle = new DefaultStyle;
    var nodeLevelStyle = new NodeLevelStyle;
    var nodeStyler = new NodeStyler(1);
    nodeStyler.setStyle(defaultStyle); // set current color mode is default or Node-Level

    var protocol = location.protocol.slice(0, -1); // location is provided from document (native variable)
    var host = location.hostname;
    var port = location.port;


    $("#webSceneInput").val("https://tiles.arcgis.com/tiles/P3ePLMYs2RVChkJx/arcgis/rest/services/Buildings_Hamburg/SceneServer/layers/0");

    // set map legend (Class from helper)
    var legend = new Legend("wrapper","i3sNodeLevelLegend"); // 'put legend at where', 'legend DOM id'
    legend.setRight("20px");
    legend.setBottom("60px");
    legend.setTitle("Node Level");
    legend.setVisible(false);
    legend.addEntry(Cesium.Color.ORANGE.toBytes().slice(0, -1), "1");
    legend.addEntry(Cesium.Color.BLUEVIOLET.toBytes().slice(0, -1), "2");
    legend.addEntry(Cesium.Color.CYAN.toBytes().slice(0, -1), "3");
    legend.addEntry(Cesium.Color.GREENYELLOW.toBytes().slice(0, -1), "4");
    legend.addEntry(Cesium.Color.DEEPPINK.toBytes().slice(0, -1), "5");
    legend.addEntry(Cesium.Color.BLUE.toBytes().slice(0, -1), "6");
    legend.addEntry(Cesium.Color.RED.toBytes().slice(0, -1), "7");
    legend.render();

    // while i3s primitive is clicked, show its id on the status bar
    scene.canvas.addEventListener("click", function(event) {
        var mousePosition = new Cesium.Cartesian2(event.layerX,event.layerY);
        var pick = scene.pick(mousePosition);
        if (!Cesium.defined(pick)) {
            return
        }
        console.log(pick.primitive.id);
        statusBar.display(pick.primitive.id)
    });

    // gather culling volume infos
    function cullingVolume2Url() {
        var planes = scene.frameState.cullingVolume.planes;
        var result = [];
        for (i = 0,
        len = planes.length; i < len; i++) {
            result.push(planes[i].x);
            result.push(planes[i].y);
            result.push(planes[i].z);
            result.push(planes[i].w)
        }
        return result.join(",")
    }

    // gather camera poistion and direction
    function camera2Url() {
        var camera = scene.frameState.camera;
        var position = camera.position;
        var direction = camera.direction;
        var result = [];
        result.push(position.x);
        result.push(position.y);
        result.push(position.z);
        result.push(direction.x);
        result.push(direction.y);
        result.push(direction.z);
        return result.join(",")
    }

    // gather frustum near, top, right values
    function frustum2Url() {
        var near = scene.frameState.camera.frustum._offCenterFrustum.near;
        var top = scene.frameState.camera.frustum._offCenterFrustum.top;
        var right = scene.frameState.camera.frustum._offCenterFrustum.right;
        var result = [];
        result.push(near);
        result.push(top);
        result.push(right);
        return result.join(",")
    }

    // gather viewer screen's width and height
    function drawingBuffer2Url() {
        var width = scene.frameState.context.drawingBufferWidth;
        var height = scene.frameState.context.drawingBufferHeight;
        var result = [];
        result.push(width);
        result.push(height);
        return result.join(",")
    }

    // remove all primitives
    function clearNodes() {
        statusBar.beginProcess("Clearing nodes");
        return new Promise((resolve,reject)=>{
            setTimeout(()=>{
                viewer.scene.primitives.removeAll();
                loadedPrimitives = {};
                resolve()
            }
            , 500)
        }
        )
    }

    // expiration time checking
    function cachedNodeHasExpired(timeOfCreation) {
        var diffInSeconds = (Date.now() - timeOfCreation) / 1e3;
        return diffInSeconds > 120
    }
    function responseHasExpired(requestTime) {
        if (requestTime < cameraChangedTime) {
            return true
        }
        return false
    }
    var cameraChangedTime;

    function makeRequest() {

        // construct url parameter, path, port
        var url = new UrlBuilder(protocol,host).port(port).path("traverse").param("i3slayer", $("#webSceneInput").val()).param("cullingvolume", cullingVolume2Url()).param("camera", camera2Url()).param("frustum", frustum2Url()).param("drawingbuffer", drawingBuffer2Url()).param("time", Date.now()).build();
        statusBar.beginProcess("Waiting for response");

        // get jquery GET ajax promise
        jsonPromise(url).then(data=>{
            var requestTime = Number(data[0].time);
            if (responseHasExpired(requestTime)) {
                return
            }
            var responseIds = data.map(function(n) {
                return n.id
            });

            // clear loaded primitives which is not in the frustum area(responseIds) and also expired
            for (let primitiveId in loadedPrimitives) {
                if (responseIds.indexOf(primitiveId) == -1 && cachedNodeHasExpired(loadedPrimitives[primitiveId][1])) {
                    viewer.scene.primitives.remove(loadedPrimitives[primitiveId]);
                    delete loadedPrimitives[primitiveId]
                }
            }

            statusBar.beginProcess("Processing nodes");
            $("#infoTable tbody").empty();
            var all_promises = [];
            for (let key in data) {
                var entity = data[key];
                if (loadedPrimitives[entity.id] == undefined) {
                    all_promises.push(processNode(entity.url, requestTime)) // parse the node (draw it)
                } else {
                    if (loadedPrimitives[entity.id][0].show == false) {
                        loadedPrimitives[entity.id][0].show = true
                    }
                }
                var markup = "<tr><td>" + entity.id + "</td><td>" + entity.lng + "</td><td>" + entity.lat + "</td></tr>";
                $("#infoTable tbody").append(markup)
            }
            Promise.all(all_promises).then(()=>{
                for (let primitiveId in loadedPrimitives) {
                    if (responseIds.indexOf(primitiveId) == -1 && !cachedNodeHasExpired(loadedPrimitives[primitiveId][1])) {
                        loadedPrimitives[primitiveId][0].show = false
                    }
                }
                statusBar.endProcess() // hide the message
            }
            )
        }
        ).catch(e=>{
            console.log(e);
            statusBar.endProcess()
        }
        )
    }

    // note!!
    // when clicking the 'Get' button:
    // 1. send request to the arcgis i3s url (/layers/0), then we know the data's bounding volume, fly the camera to the area
    // 2. then base on the frustum/camera infoamtion, send request to 3DPS server
    // 3. 3dPS server will traverse the tree nodes based on the frustum infomation in order to get the right LOD node, then return the node(i3s url)
    // 4. request the node's position, geometry, attributes...etc and draw the building
    
    var timeOutHandle;
    $("#getWebScene").click(function(event) {
        event.preventDefault();
        var url = $("#webSceneInput").val();
        if (!url) {
            statusBar.endProcess();
            return
        }
        clearNodes().then(()=>{
            entities.removeAll();
            statusBar.beginProcess("Getting scene");
            $("#infoTable tbody").empty();
            return jsonPromise(url)
        }
        ).then(data=>{
            entities.add({
                rectangle: {
                    name: "layer_extents",
                    coordinates: Cesium.Rectangle.fromDegrees(data.store.extent[0], data.store.extent[1], data.store.extent[2], data.store.extent[3]),
                    material: Cesium.Color.GREEN,
                    fill: false,
                    outline: true
                }
            });
            viewer.zoomTo(viewer.entities, new Cesium.HeadingPitchRange(0,Cesium.Math.toRadians(-45),5e3));
            if (viewer.camera.changed.numberOfListeners == 0) {
                viewer.camera.changed.addEventListener(function() {
                    cameraChangedTime = Date.now();
                    clearTimeout(timeOutHandle);
                    timeOutHandle = setTimeout(function() {
                        var now = Date.now();
                        cameraChangedTime = now;
                        makeRequest()
                    }, 1e3)
                })
            }
            statusBar.endProcess()
        }
        ).catch(e=>{
            console.log(e);
            statusBar.endProcess()
        }
        )
    });

    $("#stylesList").change(function() {
        var selection = this.value;
        switch (selection) {
        case "Default":
            nodeStyler.setStyle(defaultStyle);
            updateNodesStyle();
            legend.hide();
            break;
        case "Node Level":
            nodeStyler.setStyle(nodeLevelStyle);
            updateNodesStyle();
            legend.show();
            break;
        default:
            nodeStyler.setStyle(defaultStyle)
        }
    });
    var loadedPrimitives = {};
    function processNode(nodeUrl, requestTime) {
        return new Promise(function(resolve, reject) {
            jsonPromise(nodeUrl).then(data=>{
                var featuresUrl = nodeUrl + "/" + data.featureData[0].href;
                var geometryUrl = nodeUrl + "/" + data.geometryData[0].href;
                var nodeLevel = data.level;
                var nodeMBS = data.mbs;
                var nodeId = data.id;
                if (responseHasExpired(requestTime)) {
                    return
                }
                Promise.all([jsonPromise(featuresUrl), binaryPromise(geometryUrl)]).then(values=>{
                    if (responseHasExpired(requestTime)) {
                        return
                    }
                    var features = values[0].featureData;
                    var vertexAttributes = values[0].geometryData[0].params.vertexAttributes;
                    var geometryBuffer = values[1];
                    var instances = [];
                    for (let i = 0, len = features.length; i < len; i++) {
                        var feature = features[i];
                        var faceRange = feature.geometries[0].params.faceRange;
                        var featureVertices = new Float32Array(geometryBuffer,vertexAttributes.position.byteOffset + faceRange[0] * VERTEX_ELEMENTS_PER_TRIANGLE * Float32Array.BYTES_PER_ELEMENT,(faceRange[1] - faceRange[0] + 1) * VERTEX_ELEMENTS_PER_TRIANGLE);
                        minHeight = featureVertices.filter((coordinate,index)=>{
                            return (index + 1) % 3 == 0
                        }
                        ).reduce((a,b)=>{
                            return Math.min(a, b)
                        }
                        );
                        offsetVertices(featureVertices, nodeMBS[0], nodeMBS[1], -minHeight);
                        var cartesianPositions = Cesium.Cartesian3.fromDegreesArrayHeights(featureVertices);
                        var positions = new Float64Array(featureVertices.length);
                        cartesianToTypedArray(cartesianPositions, positions);
                        var normals = new Float32Array(geometryBuffer,vertexAttributes.normal.byteOffset + faceRange[0] * NORMAL_ELEMENTS_PER_TRIANGLE * Float32Array.BYTES_PER_ELEMENT,(faceRange[1] - faceRange[0] + 1) * NORMAL_ELEMENTS_PER_TRIANGLE);
                        var geometry = new Cesium.Geometry({
                            attributes: {
                                position: new Cesium.GeometryAttribute({
                                    componentDatatype: Cesium.ComponentDatatype.DOUBLE,
                                    componentsPerAttribute: 3,
                                    values: positions
                                }),
                                normal: new Cesium.GeometryAttribute({
                                    componentDatatype: Cesium.ComponentDatatype.FLOAT,
                                    componentsPerAttribute: 3,
                                    values: normals
                                })
                            },
                            primitiveType: Cesium.PrimitiveType.TRIANGLES,
                            boundingSphere: Cesium.BoundingSphere.fromVertices(positions)
                        });
                        var instance = new Cesium.GeometryInstance({
                            geometry: geometry,
                            attributes: {
                                color: Cesium.ColorGeometryInstanceAttribute.fromColor(nodeStyler.getColor(nodeLevel))
                            },
                            show: new Cesium.ShowGeometryInstanceAttribute(true),
                            id: feature.id
                        });
                        instances.push(instance)
                    }
                    if (responseHasExpired(requestTime)) {
                        return
                    }
                    var primitive = viewer.scene.primitives.add(new Cesium.Primitive({
                        geometryInstances: instances,
                        appearance: new Cesium.PerInstanceColorAppearance({
                            closed: true,
                            translucent: false
                        })
                    }));
                    primitive.id = nodeId;
                    primitive.level = nodeLevel;
                    loadedPrimitives[nodeId] = [primitive, Date.now()];
                    resolve()
                }
                ).catch(error=>{
                    console.log(error);
                    reject()
                }
                )
            }
            ).catch(error=>{
                console.log(error);
                reject()
            }
            )
        }
        )
    }

    function jsonPromise(url) {
        return new Promise((resolve,reject)=>{
            $.ajax({
                url: url,
                type: "GET",
                dataType: "json",
                success: function(data) {
                    resolve(data)
                },
                error: function(error) {
                    reject(error.responseText)
                }
            })
        }
        )
    }
    function binaryPromise(url) {
        return new Promise((resolve,reject)=>{
            $.ajax({
                url: url,
                type: "GET",
                xhrFields: {
                    responseType: "arraybuffer"
                },
                processData: false,
                success: function(data) {
                    resolve(data)
                },
                error: function(error) {
                    reject(error.responseText)
                }
            })
        }
        )
    }
    function fetchPayloads(data) {
        var featuresUrl = nodeUrl + "/" + data.featureData[0].href;
        var geometryUrl = nodeUrl + "/" + data.geometryData[0].href;
        var nodeMBS = data.mbs;
        return Promise.all([jsonPromise(featuresUrl), binaryPromise(geometryUrl)])
    }
    function offsetVertices(vertices, xOffset, yOffset, zOffset) {
        for (let i = 0, len = vertices.length; i < len; i += 3) {
            vertices[i] += xOffset;
            vertices[i + 1] += yOffset;
            vertices[i + 2] += zOffset
        }
    }
    function cartesianToTypedArray(cartesianArray, typedArray) {
        for (let i = 0, len = cartesianArray.length; i < len; i++) {
            typedArray[i * 3] = cartesianArray[i].x;
            typedArray[i * 3 + 1] = cartesianArray[i].y;
            typedArray[i * 3 + 2] = cartesianArray[i].z
        }
    }
    function updateNodesStyle() {
        for (let key in loadedPrimitives) {
            let primitive = loadedPrimitives[key][0];
            let primitiveIds = primitive._instanceIds;
            for (let i = 0, len = primitiveIds.length; i < len; i++) {
                let attributes = primitive.getGeometryInstanceAttributes(primitiveIds[i]);
                attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(nodeStyler.getColor(primitive.level))
            }
        }
    }
    function NodeStyler() {
        var style;
        this.setStyle = function(newStyle) {
            style = newStyle
        }
        ;
        this.getColor = function(nodeLevel) {
            return style.getColor(nodeLevel)
        }
    }
    function DefaultStyle() {
        this.getColor = function(nodeLevel) {
            return Cesium.Color.DARKGREY
        }
    }
    function NodeLevelStyle() {
        this.getColor = function(nodeLevel) {
            var result;
            switch (true) {
            case nodeLevel == 1:
                result = Cesium.Color.ORANGE;
                break;
            case nodeLevel == 2:
                result = Cesium.Color.BLUEVIOLET;
                break;
            case nodeLevel == 3:
                result = Cesium.Color.CYAN;
                break;
            case nodeLevel == 4:
                result = Cesium.Color.GREENYELLOW;
                break;
            case nodeLevel == 5:
                result = Cesium.Color.DEEPPINK;
                break;
            case nodeLevel == 6:
                result = Cesium.Color.BLUE;
                break;
            case nodeLevel == 7:
                result = Cesium.Color.RED;
                break;
            default:
                result = Cesium.Color.DARKGREY
            }
            return result
        }
    }
});
